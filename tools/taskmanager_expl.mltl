STRUCT
    task: { start, exec, end: bool, start_ts, end_ts: int };
    task_manager: { task_set: set<task>, num_active: int };

VAR
    t1st,t1ex,t1ed,t2st,t2ex,t2ed,t3st,t3ex,t3ed,t4st,t4ex,t4ed,t5st,t5ex,t5ed,t6st,t6ex,t6ed: bool;
    t1stts,t1edts,t2stts,t2edts,t3stts,t3edts,nact1,t4stts,t4edts,t5stts,t5edts,t6stts,t6edts,nact2: int;

    task1,task2,task3,task4,task5,task6: task;
    tm1,tm2: task_manager;

    Order: t1st,t1ex,t1ed,t1stts,t1edts,t2st,t2ex,t2ed,t2stts,t2edts,t3st,t3ex,t3ed,t3stts,t3edts,nact1,
           t4st,t4ex,t4ed,t4stts,t4edts,t5st,t5ex,t5ed,t5stts,t5edts,t6st,t6ex,t6ed,t6stts,t6edts,nact2;

    -- sample input:
    -- tm1.t1    | tm1.t2    | tm1.t3    | tm1.num_active | tm2.t1    | tm2.t2    | tm2.t3    | tm2.num_active
    -- 0,1,0,5,0 , 0,0,0,0,0 , 0,0,1,3,8 , 1,               0,1,0,9,0 , 0,1,0,7,0 , 0,0,0,0,0 , 2 

DEFINE
    task1 = task(t1st,t1ex,t1ed,t1stts,t1edts); -- case 1
    task2 = {t2st,t2ex,t2ed,t2stts,t2edts}; -- case 2, conflicts with set syntax
    task2 = {.start = t2st, .exec = t2ex, .end = t2ed, .start_ts = t2stts, .end_ts = t2edts}; -- case 3


    task3 = {t3st,t3ex,t3ed,t3stts,t3edts};
    task4 = {t4st,t4ex,t4ed,t4stts,t4edts};
    task5 = {t5st,t5ex,t5ed,t5stts,t5edts};
    task6 = {t6st,t6ex,t6ed,t6stts,t6edts};

    tm1 = {{task1,task2,task3},nact1};
    tm1 = {{task4,task5,task6},nact2};

    TM = {tm1,tm2};

SPEC
    -- for all task managers tm, if there is at least one active task then
    -- there exists a task t in tm's task set such that t is in the exec state 
    forall(tm: TM) ((tm.num_active > 0) -> exists(t: tm.task_set) (t.exec))

    -- for all task managers tm, if all task slots are active, then within
    -- the next ten time steps at least one slot will become inactive and
    -- at least one task will enter the end state and until then the number
    -- of active tasks will remain at 3.
    forall(tm: TM) ((tm.num_active == 3) -> (tm.num_active == 3) U[0,10] (tm.num_active < 3 && exists(t: tm.task_set) (t.end)))